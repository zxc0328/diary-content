## Regular Template Syntax

> simple LL(1) parser

Tokens

TEXT
NAME
UNQ
TAG_OPEN
TAG_CLOSE
STRING
OPEN
CLOSE

Lexer

Lexer里有一个细节，就是Regular里可以定义表达式里标志开始和结束的Symbol。所以Rule里面的正则表达式是需要经过替换才能使用的。替换的对象就是macro。

Lexer里有一些macro，就是预定义的正则。

macro里面的IDENT是identifier的意思。

BEGIN和END是可以由用户定义的macro。

这种机制提供了简单的抽象和灵活度。

Regular AST Design

节点的定义在*parser/node.js*里面。

Regular的AST里比较复杂的就是expression对象。

EBNF (大写的常量是非终结符)

```
statement -> xml | jst | text
program -> EOF | (statement)* EOF
xml -> stag statement* TAG_CLOSE?
stag -> '<' Name (S attr)* S? '>'  
attr -> Name Eq attvalue
attvalue -> STRING | NAME
assign -> left-hand-expr (['=', '+=', '-=', '*=', '/=', '%='] condition)?
condition -> or (? assign : assign)*
```

优化备忘：

+ Vue的环境变量，不同环境特定的warn代码
+ AOT
+ 类似React的ShouldComponentUpdate一样的一个生命周期函数