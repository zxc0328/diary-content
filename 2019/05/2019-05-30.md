## Golang 分布式 crontab 课程笔记



### Golang + cron 表达式

crontab 是 Linux 自带的定时任务工具。可以基于一个 cron 表达式来定时执行任务。

> [cron 表达式网站](https://crontab.guru/)

在 Golang 中对 cron 表达式进行解析可以用 `github.com/gorhill/cronexpr` 这个库。具体的用法可以看课程源码里面的 prepare/cron_usage。简单的说就需要有一个 Loop，定时检查是否有任务已经到期，到期了就执行这样。

这个课程就是要实现一个分布式的 crontab，可以对任务进行分布式调度，并且可以看到任务的执行情况。

***

### etcd

这个项目对 etcd 有比较重的依赖。主要集中在任务的存储，和分布式锁两个方面。

etcd 本身是一个分布式的 kv store。他的特点如下：

+ 支持基本的 kv 的 CRUD 操作
+ 使用 Raft 协议保证多个节点之间的数据一致性
+ 会选举出一个 Leader，半数以上的节点投票决定 Leader，所以 etcd 的节点数量应该是单数
+ Leader 拿到操作后，会先写入本地的 Write Ahead Log，然后这条日志同步给大多数个节点后（不需要写入存储），Leader 就会本地提交，然后返回给客户端。后续会异步通知其他节点对 Log 进行本地提交。这是一个两阶段协议
+ key 是有序的，也就是说如果 key 是目录形式（`/cron/jobs/job2`），那就可以进行目录内容的顺序遍历
+ 支持 lease（租约），用于实现 key 的自动过期
+ 支持事务，事务是指一个 IF ... THEN ... ELSE 操作
+ 支持 lock（分布式锁）（这个课程出的时候 etcd 还不支持这个，所以是用 lease + 事务实现的分布式锁）
+ 支持 key 的多版本（Revision）
+ 支持对 key 进行 watch，实现发布-订阅

里面讲到了一个[抽屉原理（quorum 机制）](https://zh.wikipedia.org/wiki/Quorum_(%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F))。

+ [分布式理论——quorum原理](https://www.cnblogs.com/gudi/p/8060326.html)
+ [分布式系统理论之Quorum机制](https://www.cnblogs.com/hapjin/p/5626889.html)

这个原理决定了 Raft 的投票逻辑和复制逻辑的时候只要大多数节点同意或者收到日志就可以当做整个系统都认可了。这个原理和鸽巢原理比较像，如果一个事情，一个班里有一半以上的人知道，那你问一半 + 1 个人，就可以知道这个事情，所以这个数据就等于是已经存储了。

quorum 无法保证强一致性，当然强一致性也是分布式系统中最难实现的一个目标。写入只是写入了大多数节点，如果读的是其他节点，数据就是旧的。当写入了大多数节点之后，读 V/2 + 1 次，就一定可以读到最新的数据，要想确定最新的数据是什么，就需要最多读 V 次来确认（出现了 V/2 + 1 次的就是最新数据）。

相比于需要同步到所有副本的 Write All Read one 算法，quorum 机制的写入性能要更好，不会因为单点故障就无法写入。

还有一个 [CAP 原理](https://www.jianshu.com/p/f96a259e3757)。CAP 里主要说的就是 CAP 里面我们最多只能保证两个，被放弃的往往是一致性，我们追求的是最终一致性，就是在写入之后的一段时间内，所有节点的状态达到一致就可以。对一致性的需求和具体的应用相关，要具体问题具体分析，但总的来说互联网，如果是普通的业务，对强一致性的追求不高。


***

### 架构设计

Master 和 Worker 之间相互没有耦合，两者的状态是通过 etcd 进行共享的，通信用的是 etcd 的 watch 机制。并且 Worker 的服务注册也是用 etcd 实现的。Master 和 Worker 都是无状态的，可以简单的水平拓展。

#### Master

Master 比较简单，主要是一个 Apiserver，然后是任务管理和节点管理，用于向 etcd 做 CRUD 操作。Master 还带了一个简单的管理后台 UI 用来做操作。

#### Worker

主要模块：

+ 调度器
+ 日志写入模块
+ 任务管理
+ 任务加锁
+ 任务执行器

整个 Worker 的流程：

+ 初始化调度器，运行调度循环，从 jobEventChan 里面监听任务的 CRUD 事件，把任务执行计划放到 jobPlanTable 这个结构中保存。
+ 初始化任务管理器，连接 etcd，先获取 etcd 中的所有任务，然后启动监听，实时把 job 的修改推送给调度器。
+ 调度器中调度循环，每次都会 TrySchedule 尝试调度，遍历 jobPlanTable 看哪个任务到期了，然后 TryStartJob 给执行器执行。在这个循环的过程里面会看哪个任务是最近一个到期的，会把 scheduleAfter 变量设置为这个时间。调度循环每次都会重新设置 Sleep 的时间为 scheduleAfter，这样就实现了一个精确的睡眠，减少无用的调度循环检查。
+ 任务执行时首先会调任务加锁模块尝试获取分布式锁，如果锁没拿到说明有其他节点在执行任务了，所以就跳过这次执行。不管如何，都更新执行计划中的 NextTime。


> 值得注意的是，每个 Worker 都是从 etcd 里面拿到任务，然后在本地构建一个执行计划表，然后执行。多个节点之间，每个节点的执行计划和执行结果等等都是私有的本地变量。唯一起到协调作用的就是分布式锁，如果一个任务在执行时发现已经有其他节点在执行，那就会跳过本次调度，更新下次调度时间。如果发现一个任务执行时间很长，到了下次调度还在执行中，那也会跳过执行，更新下次调度时间。这个设计其实是这个架构里最“分布式”的点。这个架构的好处就是，不会存在特别空的节点，因为一个节点同时只能执行一个任务，其他节点必然会被分配到其他的任务。

***

### 总结

这门课主要的收获就是：

+ 了解了 etcd 的功能和使用
+ 了解了这样一个分布式系统的设计，但我还不能对其进行判断（优劣），因为脑子里的设计方案存货太少了。这个方案是一个参考。不过总的来说目前的（业务）分布式系统是一定要依赖一些中间件的，这个系统就依赖了 etcd 作为核心的中间件
+ 了解了 go routine 和 channel 的使用。go routine 主要是做守护进程，循环监听。channel 就主要是模块和模块之间一个通信的渠道。
+ 总的来说还是一个很有意思，很有帮助的课程
