## TS å­¦ä¹ æ€»ç»“ï¼šç¼–è¯‘é€‰é¡¹ && ç±»å‹ç›¸å…³æŠ€å·§


### ç¼–è¯‘å™¨é€‰é¡¹

åˆæ³•çš„ JS ä»£ç å°±æ˜¯åˆæ³•çš„ TS ä»£ç ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ä½¿ç”¨ TS çš„æ—¶å€™ï¼Œåœ¨é»˜è®¤çš„ç¼–è¯‘å™¨é…ç½®ä¸‹ï¼Œå—åˆ°çš„çº¦æŸæ¯”è¾ƒå°‘ã€‚ä¸ºäº†ä¸è®© TypeScript å˜æˆ AnyScriptï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ TS çš„ç¼–è¯‘å™¨é€‰é¡¹ï¼Œå¹¶è¿›è¡Œåˆç†çš„é…ç½®ã€‚TS é…ç½®ä¸­æœ‰ä¸€ä¸ª `--strict`ï¼Œå¼€å¯äº†è¿™ä¸ªé€‰é¡¹å°±ç­‰äºå¼€å¯äº† `--noImplicitAny, --noImplicitThis, --alwaysStrict, --strictBindCallApply, --strictNullChecks, --strictFunctionTypes and --strictPropertyInitialization.`ã€‚ä¸‹é¢å°±æ¥è§£æä¸€ä¸‹è¿™äº›é€‰é¡¹çš„ä½œç”¨ï¼š

#### `--noImplicitAny`

TS Deep Dive ä¸­çš„ç›¸å…³[è¯´æ˜](https://basarat.gitbooks.io/typescript/docs/options/noImplicitAny.html)ã€‚è¿™ä¸ªé€‰é¡¹ä¸æ˜¯è¯´ä¸èƒ½ä½¿ç”¨ anyï¼Œæ˜¯ä¸èƒ½ä½¿ç”¨éšå¼çš„ anyã€‚æ¯”å¦‚ä¸€ä¸ªå‡½æ•°çš„å…¥å‚ï¼Œå¦‚æœæ²¡æœ‰è¿›è¡Œç±»å‹æ ‡æ³¨ï¼Œé‚£è¿™ä¸ªç±»å‹å°±æ˜¯ anyã€‚è¿™æ˜¯éšå¼çš„ã€‚è¿™ä¸ªé€‰é¡¹è¦æ±‚ä½ æŠŠæ‰€æœ‰éœ€è¦æ ‡æ³¨ç±»å‹çš„åœ°æ–¹éƒ½åŠ ä¸Šç±»å‹ã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥åœ¨è¿™äº›åœ°æ–¹éƒ½ä½¿ç”¨ anyï¼Œé‚£å°±æ˜¯å¦ä¸€å›äº‹äº†ã€‚å¯ä»¥ä½¿ç”¨ Linter æ¥ç¦æ­¢å¯¹æ˜¾ç¤º any çš„ä½¿ç”¨ã€‚ä½†æœ‰æ—¶å€™ any ä¹Ÿæ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚[è¿™ç¯‡æ–‡ç« ](https://zhuanlan.zhihu.com/p/62292091)é‡Œæåˆ°çš„ã€‚ä¸ç®¡å¦‚ä½•ï¼Œåœ¨çº¯ TS é¡¹ç›®é‡Œï¼ŒnoImplicitAny è¿˜æ˜¯æœ‰å¿…è¦å¼€å¯çš„ã€‚

#### `--noImplicitThis`

å¦‚æœæ¨æ–­å‡º this çš„ç±»å‹æ˜¯ anyï¼Œå°±ä¼šæŠ¥é”™ã€‚è¿™æ ·å°±å¯ä»¥é¿å…ä¸€äº›å› ä¸º this æŒ‡å‘ä¸æ­£ç¡®è€Œé€ æˆçš„é—®é¢˜ã€‚å…·ä½“å¯ä»¥çœ‹[è¿™é‡Œ](https://jkchao.github.io/typescript-book-chinese/typings/thisType.html)ã€‚

#### `--strictBindCallApply`

è¿™ä¸ªé€‰é¡¹ä¼šåœ¨ bindï¼Œcallï¼Œå’Œ apply æ—¶ï¼Œæ ¹æ®åŸå‡½æ•°çš„ç±»å‹ç­¾åå¯¹è°ƒç”¨è¿›è¡Œç±»å‹æ ¡éªŒã€‚æ˜¯åœ¨ TS 3.2 ç‰ˆæœ¬ä¸­åŠ å…¥çš„ã€‚

```
function foo(a: number, b: string): string {
    return a + b;
}

let a = foo.apply(undefined, [10]);              // error: too few argumnts
let b = foo.apply(undefined, [10, 20]);          // error: 2nd argument is a number
let c = foo.apply(undefined, [10, "hello", 30]); // error: too many arguments
let d = foo.apply(undefined, [10, "hello"]);     // okay! returns a string
```

> è¿™ä¸ªæ£€æŸ¥åœ¨æ³›å‹å‡½æ•°å’Œæœ‰é‡è½½çš„å‡½æ•°æœ‰ä¸€äº›é™åˆ¶

#### `--strictNullChecks`


å¼€å¯äº†è¿™ä¸ªé€‰é¡¹ä¹‹åï¼Œnullï¼Œundefined ä¸¤ä¸ªç±»å‹ä¼šè¢«åŒºåˆ†å¼€æ¥ã€‚`T` å’Œ `T | undefined` ä¹Ÿä¼šæ˜¯ä¸åŒçš„ç±»å‹ã€‚ä¸€ä¸ªç±»å‹å¿…é¡»æ˜¾å¼è¯´æ˜æœ‰å¯èƒ½ä¸º undefinedã€‚è¿™ä¸ªæ£€æŸ¥ä½¿å¾—ä¸€äº› undefined é”™è¯¯å¯ä»¥è¢«æ£€æŸ¥å‡ºæ¥ã€‚å…·ä½“ä¾‹å­å‚è€ƒ [TS Deep Dive çš„ç›¸å…³ç« èŠ‚](https://basarat.gitbooks.io/typescript/docs/options/strictNullChecks.html)ã€‚

### ç±»å‹ç›¸å…³æŠ€å·§

ä¸‹é¢æ€»ç»“ä¸€ä¸‹ TS ä¸­çš„ç±»å‹ç›¸å…³çš„ä¸€äº›æ¯”è¾ƒé«˜çº§çš„å†…å®¹

#### é«˜çº§ç±»å‹

TS å®˜æ–¹æ‰‹å†Œä¸­çš„ [Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html) ç« èŠ‚ä¸­æåˆ°äº†ä¸€äº›é«˜çº§ç±»å‹ã€‚é€šè¿‡åˆç†çš„ä½¿ç”¨è¿™äº›é«˜çº§ç±»å‹ï¼Œå¯ä»¥è®©æˆ‘ä»¬çš„ç±»å‹æ£€æŸ¥å’Œæ¨æ–­æ›´å®Œå–„å’Œä¾¿æ·ã€‚


##### Mapped types

Mapped types æŒ‡çš„æ˜¯æŠŠä¸€ä¸ªç±»å‹çš„å±æ€§è¿›è¡Œæ˜ å°„äº§å‡ºçš„æ–°ç±»å‹ã€‚

**Partial<T>**

Partial ä¼šæŠŠä¸€ä¸ªç±»å‹ä¸­æ‰€æœ‰çš„å±æ€§éƒ½å˜æˆ Optionalï¼Œåœ¨ä¸šåŠ¡ä¸­ä¸€äº›ç±»å‹åœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œä¸ä¸€å®šæ‰€æœ‰å±æ€§éƒ½æœ‰å€¼ï¼Œè¿™ä¸ªæ—¶å€™ Partial å¾ˆå¸¸ç”¨ã€‚

```
const mergeOptions = (options: Opt, patch: Partial<Opt>) {
  return { ...options, ...patch };
}

class MyComponent extends React.PureComponent<Props> {
  defaultProps: Partial<Props> = {};
}
```

**Record<K,T>**

ä¸šåŠ¡ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šå†™æšä¸¾å’Œå¯¹åº”çš„æ˜ å°„ï¼Œ`Record` å¯ä»¥ä¿è¯æ˜ å°„å®Œæ•´:

```
type AnimalType = 'cat' | 'dog' | 'frog';
interface AnimalDescription { name: string, icon: string }
const AnimalMap: Record<AnimalType, AnimalDescription> = {
  cat: { name: 'çŒ«', icon: 'ğŸ±'},
  dog: { name: 'ç‹—', icon: 'ğŸ¶' },
  forg: { name: 'è›™', icon: 'ğŸ¸' }, // æ‹¼å†™é”™è¯¯ï¼
};
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒRecord ä¸æ˜¯ homomorphic çš„ã€‚
```
Readonly, Partial and Pick are homomorphic whereas Record is not. One clue that Record is not homomorphic is that it doesnâ€™t take an input type to copy properties from:
```

##### Conditional Types

å¼ºçƒˆæ¨èé˜…è¯» -> [Conditional types in TypeScript - David Sheldrick](https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/) å†™çš„å¾ˆé€šä¿—æ˜“æ‡‚ï¼Œå¹½é»˜é£è¶£ã€‚

æ¨èé˜…è¯» -> [Conditional Types in TypeScript - Marius Schulz](https://mariusschulz.com/blog/conditional-types-in-typescript) å†™çš„å¾ˆè¯¦ç»†ï¼Œæ¯”å®˜æ–¹æ–‡æ¡£æ€»ç»“çš„æ›´å¥½ã€‚

æ¡ä»¶ç±»å‹çš„ç”¨æ³•æ˜¯è¿™æ ·çš„ï¼š

`T extends U ? X : Y`

å¦‚æœ T å’Œ U å…¼å®¹ï¼ˆT åŒ…å« U æœ‰çš„æ‰€æœ‰å±æ€§ï¼ŒT å¯ä»¥è¢«èµ‹å€¼ç»™ Uï¼‰ï¼Œè¿™ä¸ªç±»å‹å°±æ˜¯ Xï¼Œå¦åˆ™å°±æ˜¯ Yã€‚

çœ‹ä¸€ä¸‹æ¡ä»¶ç±»å‹çš„å®é™…ç”¨é€”ï¼š

æ¯”å¦‚æœ‰å¦‚ä¸‹çš„å‡½æ•°ï¼Œå¯èƒ½è¿”å› stringï¼Œä¹Ÿå¯èƒ½æ˜¯ nullï¼š

```
function process(text: string | null): string | null {
  return text && text.replace(/f/g, "p")
}
```

ä½†è¿™æ ·çš„ç±»å‹å†™æ³•æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºè¿”å›å€¼æœ‰å¯èƒ½æ˜¯ nullï¼Œæ²¡æœ‰ toUpperCase è¿™ä¸ªæ–¹æ³•ã€‚
```
//            âŒ„ Type Error! :(
process("foo").toUpperCase()
```

è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥ç”¨æ¡ä»¶ç±»å‹æ¥è§£å†³ï¼š

```
function process<T extends string | null>(
  text: T
): T extends string ? string : null {
  ...
}

```

**distributive conditional types**

> Conditional types in which the checked type is a naked type parameter are called distributive conditional types. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of T extends U ? X : Y with the type argument A | B | C for T is resolved as (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y).

å¦‚æœæ¡ä»¶ç±»å‹ extends å·¦è¾¹çš„å‚æ•°æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹å˜é‡çš„è¯ï¼Œè¿™ä¸ªå˜é‡æœ‰æ˜¯ä¸€ä¸ªè”åˆç±»å‹ï¼Œé‚£æ¡ä»¶ç±»å‹å°±æ˜¯åˆ†å¸ƒåˆ°è”åˆç±»å‹çš„æ¯ä¸€ä¸ªæˆå‘˜ä¸Šï¼Œè¿”å›ä¸€ä¸ªæ–°çš„è”åˆç±»å‹ã€‚è¿™æœ‰ç‚¹ç±»ä¼¼ Mapï¼Œåªä¸è¿‡ä½œç”¨çš„æ˜¯ç±»å‹å˜é‡ã€‚

åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹å’Œ never ç±»å‹ä¸€èµ·ç”¨ï¼Œå¯ä»¥èµ·åˆ°ä¸€ä¸ªç­›é€‰çš„æ•ˆæœã€‚æ¯”å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ªæ¡ä»¶ç±»å‹å« NonNullableï¼š

```
type NonNullable<T> = T extends null | undefined ? never : T;
```

ç”¨èµ·æ¥å°±æ˜¯è¿™æ ·çš„ï¼š

```
type T34 = NonNullable<string | number | undefined>;  // string | number
type T35 = NonNullable<string | string[] | null | undefined>;  // string | string[]
```

å¦‚æœè¿”å›çš„ç±»å‹ä¸­æœ‰ neverï¼Œå°±ä¼šåœ¨è”åˆç±»å‹ä¸­è¢«ä¸¢å¼ƒï¼Œè¿™æ ·å°±äº§ç”Ÿäº†ç­›é€‰çš„æ•ˆæœã€‚


**Type inference in conditional types**

åœ¨æ¡ä»¶ç±»å‹ä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ infer å…³é”®è¯æ¥è¡¨ç¤ºé€šè¿‡ç±»å‹æ¨å¯¼è·å¾—çš„ç±»å‹ã€‚æ¯”å¦‚æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå« ReturnType çš„æ¡ä»¶ç±»å‹ï¼Œç”¨æ¥è·å–å‡½æ•°çš„è¿”å›å€¼ç±»å‹ï¼š

```
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
```

ç±»ä¼¼çš„è¿˜æœ‰ Parameters ç±»å‹ï¼š

```
type Parameters<T extends (...args: any[]) => any> =
  T extends (...args: infer P) => any
    ? P
    : never;
```


##### Index types

**index type query and indexed access**

```
function getProperty<T, K extends keyof T>(o: T, propertyName: K): T[K] {
    return o[propertyName]; // o[propertyName] is of type T[K]
}
```

##### Utility Types

ä¸Šè¿°çš„é«˜çº§ç±»å‹ï¼Œåœ¨ TS ä¸­å·²ç»å†…ç½®çš„ï¼š

+ Partial<T>
+ Readonly<T>
+ Record<K,T>
+ Pick<T,K>
+ Omit<T,K>
+ Exclude<T,U>
+ Extract<T,U>
+ NonNullable<T>
+ ReturnType<T>
+ InstanceType<T>
+ Required<T>
+ ThisType<T>
+ Partial<T>

#### Interface VS Type Alias

interface å…³é”®è¯å’Œ type å…³é”®è¯çš„åŒºåˆ«ï¼š


[Interface vs Type alias in TypeScript 2.7](https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c)

å®˜ç½‘æ–‡æ¡£ä¸­åœ¨ [Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html) ä¸­æœ‰ä¸€ç« è®² Interface VS Type Alias çš„åŒºåˆ«ï¼Œä½†å…¶ä¸­æœ‰ä¸€äº›å·²ç»è¿‡æ—¶äº†ï¼Œå¹¶ä¸”è¿˜æœ‰ä¸€äº›åŒºåˆ«æ²¡è¦†ç›–åˆ°ã€‚æ‰€ä»¥ä¸Šé¢åˆ—å‡ºçš„åšå®¢ï¼Œåˆ—å‡ºäº†åœ¨ 2.7 ç‰ˆæœ¬ä¸­ interface å…³é”®è¯å’Œ type å…³é”®è¯çš„åŒºåˆ«ï¼š


+ type aliases can act sort of like interfaces, however, there are 3 important differences **( union types, declaration merging)**
+ use whatever suites you and your team, just be consistent
+ always use interface for public API's definition when authoring a library or 3rd party ambient type definitions
+ consider using type for your React Component Props and State

ä¸Šé¢çš„ä¸¤ç‚¹åŒºåˆ«ï¼Œunion types å’Œ declaration mergingï¼Œå¯ä»¥è¯¦ç»†çœ‹ä¸Šé¢çš„åšæ–‡ã€‚
